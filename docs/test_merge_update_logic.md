# Merge Update 实现逻辑说明

## 核心功能：`t show | t update col1=@col1 where col2=@col2`

### 实现逻辑

对于每条管道记录（show 的输出），执行以下步骤：

1. **读取管道记录**
   - 从 `show` 命令的输出中读取一条记录
   - 格式：`rec123 联系人姓名=张三 状态=待处理 联系电话=13800138000`

2. **构建查询条件（where 部分）**
   - 对于 `where col2=@col2`，从管道记录中获取 `col2` 字段的值
   - 例如：`where 联系人姓名=@联系人姓名`
   - 从管道记录中取 `联系人姓名=张三`
   - 构建查询条件：在目标表中查找 `联系人姓名=张三` 的记录

3. **查询目标表**
   - 使用构建的查询条件在目标表中查找匹配的记录
   - 可能找到0条、1条或多条匹配记录

4. **构建更新数据（update 部分）**
   - 对于 `col1=@col1`，从管道记录中获取 `col1` 字段的值
   - 例如：`状态=@状态`
   - 从管道记录中取 `状态=待处理`
   - 构建更新数据：`状态=待处理`

5. **更新匹配的记录**
   - 用构建的更新数据更新所有匹配的记录
   - 如果找到多条匹配记录，都会用管道记录中的值更新

### 多条管道记录的处理

如果 `show` 输出了多条记录，每条记录都会独立处理：

```
管道记录1: rec001 联系人姓名=张三 状态=待处理
  → 查询: 联系人姓名=张三
  → 更新: 状态=待处理（用记录1的值）

管道记录2: rec002 联系人姓名=李四 状态=已完成
  → 查询: 联系人姓名=李四
  → 更新: 状态=已完成（用记录2的值）

管道记录3: rec003 联系人姓名=王五 状态=处理中
  → 查询: 联系人姓名=王五
  → 更新: 状态=处理中（用记录3的值）
```

### 示例

```bash
# 假设 show 输出：
# rec001 联系人姓名=张三 状态=待处理
# rec002 联系人姓名=李四 状态=已完成

# 执行命令：
t show | t update 状态=@状态 where 联系人姓名=@联系人姓名

# 处理流程：
# 1. 处理记录1：
#    - where条件：联系人姓名=张三（从记录1获取）
#    - 查询目标表：找到联系人姓名=张三的记录（假设找到1条）
#    - 更新字段：状态=待处理（从记录1获取）
#    - 更新结果：更新1条记录
#
# 2. 处理记录2：
#    - where条件：联系人姓名=李四（从记录2获取）
#    - 查询目标表：找到联系人姓名=李四的记录（假设找到1条）
#    - 更新字段：状态=已完成（从记录2获取）
#    - 更新结果：更新1条记录
#
# 最终：处理2条管道记录，更新2条目标记录
```

### 关键点

1. **每条管道记录独立处理**：每条记录都有自己的查询条件和更新值
2. **值来自管道记录**：where 条件和 update 字段的值都从当前处理的管道记录中获取
3. **可能匹配多条**：如果 where 条件匹配到多条记录，都会用管道记录的值更新
4. **流式处理**：逐条处理，不需要等待所有数据加载完成

