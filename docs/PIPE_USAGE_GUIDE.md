# Teable CLI 管道操作使用指南

## 快速入门

管道操作让 Teable CLI 支持 Linux 风格的命令链式处理，实现流式数据处理和批量操作。

### 基本语法
```bash
t show [条件] | Unix命令 | t insert/update [参数]
t show | t insert | t update | t show  # 链式管道操作
```

## 核心功能

### 1. show 命令管道输出

`show` 命令在管道模式下输出简洁格式，每条记录一行：
```
rec123 字段1=值1 字段2=值2 字段3=值3
```

**格式说明：**
- 第一列：记录ID（rec开头）
- 后续列：字段名=字段值，空格分隔

**示例：**
```bash
# 查看前10条记录
t show limit=10 | head -10

# 统计记录数量
t show | wc -l

# 查找包含关键词的记录
t show | grep "张三"

# 排序显示
t show | sort
```

### 2. show | insert 管道插入

**必须指定字段映射或常量值**，支持两种方式：

#### 字段映射语法：`目标字段=@源字段` 或 `目标字段=$源字段`
- 从管道记录中获取指定字段的值
- `@字段名` 和 `$字段名` 功能相同

#### 常量值语法：`目标字段=常量值`
- 直接使用指定的常量值
- 即使管道记录中有同名字段，也使用常量值

**示例：**
```bash
# 字段映射：从管道记录中获取值
t show limit=1 | t insert 订单号=@订单号 客户名称=@客户名称

# 常量值：直接指定值
t show limit=1 | t insert 订单号=ORD999 状态=已完成

# 混合使用：部分字段映射，部分常量值
t show limit=1 | t insert 订单号=@订单号 客户名称=@客户名称 状态=新订单 备注=来自管道

# 批量插入多条记录
t show 状态=待处理 | head -10 | t insert 订单号=@订单号 状态=已复制
```

**注意事项：**
- 管道模式下**必须**提供字段映射参数，否则会提示错误
- 只插入指定的字段，其他字段使用默认值或留空
- 自动跳过系统字段（id, createdTime等）和不可编辑字段（公式字段等）

### 3. show | update 管道更新

支持两种更新模式：

#### 3.1 直接更新模式

更新管道记录本身（记录ID来自show输出）。

**语法：**
```bash
t show | t update 字段1=值1 字段2=值2 ...
```

**示例：**
```bash
# 批量更新查询结果（使用常量值）
t show 状态=待处理 | t update 状态=处理中

# 使用字段映射更新（从管道记录中获取值）
t show | t update 新状态=@状态 备注=@备注

# 混合使用字段映射和常量值
t show | t update 状态=已完成 处理人=@处理人 完成时间=2024-01-01

# 条件流式更新（只更新前5条）
t show 优先级=高 | head -5 | t update 处理人=张三

# 指定表名更新（更新指定表，而不是当前表）
t show | t update 订单表 状态=已完成
t show | t update 订单表 状态=@状态 备注=@备注
```

#### 3.2 Merge Update 模式

根据 where 条件查找目标表中匹配的记录并更新，类似 SQL 的 `UPDATE ... SET ... WHERE ...`。

**语法：**
```bash
t show | t update 字段1=值1 字段2=值2 ... where 条件字段1=值1 条件字段2=值2 ...
```

**核心功能：`update col1=@col1 where col2=@col2`**

**处理逻辑：**
1. 从管道读取一条记录（show的输出）
2. 构建 where 查询条件：`@字段名` 从当前管道记录中获取值
3. 在目标表中查询匹配的记录
4. 构建更新数据：`@字段名` 从当前管道记录中获取值
5. 更新所有匹配的记录
6. 重复处理下一条管道记录

**多条记录处理：**
- 每条管道记录独立处理
- 每条记录用自己的值构建查询条件和更新数据
- 流式处理，逐条处理，不需要等待所有数据

**示例：**
```bash
# 基本用法：根据管道记录中的字段值查找并更新匹配的记录
t show | t update 状态=已完成 where 订单号=@订单号

# 更新字段和where条件都使用@字段名（核心功能）
t show | t update 状态=@状态 where 订单号=@订单号
# 说明：从管道记录中取"订单号"值查询，取"状态"值更新

# 多个条件：使用管道记录中的多个字段值作为查询条件
t show | t update 状态=已完成 备注=@备注 where 订单号=@订单号 客户名称=@客户名称

# 混合条件：部分条件使用管道记录的值，部分使用常量值
t show | t update 状态=已完成 where 订单号=@订单号 状态=待处理

# 复杂条件：支持比较操作符
t show | t update 优先级=高 where 金额>@金额 状态=正常

# 指定表名进行 merge update
t show | t update 订单表 状态=已完成 where 订单号=@订单号
t show | t update 订单表 状态=@状态 where 订单号=@订单号 客户名称=@客户名称
```

**字段映射语法：**
- **更新字段**：
  - `目标字段=@源字段`：从管道记录中获取字段值
  - `目标字段=常量值`：使用常量值
- **Where 条件**：
  - `字段名=@源字段`：使用管道记录中的字段值作为条件
  - `字段名=常量值`：使用常量值作为条件
  - `字段名>@源字段` 或 `字段名>常量值`：大于条件
  - `字段名<@源字段` 或 `字段名<常量值`：小于条件

**示例对比：**
```bash
# 假设管道记录包含: 订单号=ORD001 客户名称=张三 状态=待处理

# 直接更新模式：更新管道记录本身（记录ID为 rec123）
t show | t update 状态=已完成
# 效果：更新记录 rec123 的 状态=已完成

# Merge update模式：查找并更新匹配的记录
t show | t update 状态=已完成 where 订单号=@订单号
# 效果：查找 订单号=ORD001 的所有记录，更新它们的 状态=已完成

# Merge update模式：更新字段和where都使用@字段名
t show | t update 状态=@状态 where 订单号=@订单号
# 效果：查找 订单号=ORD001 的所有记录，更新它们的 状态=待处理（从管道记录获取）
```

### 4. show | show 关联查询

实现表之间的关联查询，类似 SQL 的 JOIN 操作。根据管道记录中的值查询另一个表的匹配记录。

**语法：**
```bash
t show 表1 [条件] | t show 表2 where 字段1=@源字段1 字段2=@源字段2 ...
```

**处理逻辑：**
1. 从管道读取一条记录（来自前一个 show 命令的输出）
2. 构建 where 查询条件：`@字段名` 从当前管道记录中获取值
3. 在目标表中查询匹配的记录
4. 输出匹配的记录（管道格式）
5. 重复处理下一条管道记录

**多条记录处理：**
- 每条管道记录独立处理
- 每条记录用自己的值构建查询条件
- 流式处理，逐条处理，不需要等待所有数据

**示例：**
```bash
# 基本用法：从订单表查询订单，然后根据订单中的客户名称查询客户表
t show 订单表 limit=10 | t show 客户表 where 联系人姓名=@客户名称

# 多条件查询：使用管道记录中的多个字段值作为查询条件
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称 联系电话=@联系电话

# 混合条件：部分条件使用管道记录的值，部分使用常量值
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称 状态=正常

# 链式查询：可以继续管道传递
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称 | head -5

# 指定表名查询（如果当前表不是目标表）
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称
```

**字段映射语法：**
- `字段名=@源字段`：使用管道记录中的字段值作为条件
- `字段名=常量值`：使用常量值作为条件
- `字段名>@源字段` 或 `字段名>常量值`：大于条件
- `字段名<@源字段` 或 `字段名<常量值`：小于条件
- `字段名 like @源字段` 或 `字段名 like 常量值`：模糊匹配条件

**注意事项：**
- 关联查询模式下**必须**指定 where 条件
- 字段名必须匹配：管道记录中的字段名必须与 where 条件中使用的 `@字段名` 一致
- 如果 where 条件匹配多条记录，都会输出
- 支持流式处理，适合大规模数据关联查询

**示例对比：**
```bash
# 假设订单表记录包含: 订单号=ORD001 客户名称=张三

# 关联查询：根据订单中的客户名称查询客户表
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称
# 效果：对于每条订单记录，查找客户表中联系人姓名为"张三"的记录

# 多条件关联查询
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称 联系电话=@联系电话
# 效果：查找联系人姓名和联系电话都匹配的记录
```

### 5. 链式管道操作

支持多个命令连续管道操作，实现复杂的数据处理流程。

**语法：**
```bash
t show | t insert | t update | t show ...
```

**工作原理：**
- `insert` 命令：插入成功后，如果有管道输出，会输出插入的记录
- `update` 命令：更新成功后，如果有管道输出，会输出更新的记录
- 每个命令的输出可以作为下一个命令的输入
- 自动检测管道输出模式，无需额外参数

**示例：**
```bash
# 查询 -> 插入 -> 输出
t show limit=10 | t insert 订单号=@订单号 客户名称=@客户名称

# 查询 -> 插入 -> 更新 -> 输出
t show limit=10 | t insert 订单号=@订单号 | t update 状态=已完成

# 完整链式操作：查询 -> 插入 -> 更新 -> 关联查询
t show 订单表 limit=10 | t insert 订单备份表 订单号=@订单号 | t update 订单备份表 状态=已完成 | t show 客户表 where 联系人姓名=@客户名称

# 跨表链式操作
t show 订单表 | t insert 订单备份表 订单号=@订单号 | t update 订单备份表 状态=已备份 | t show 客户表 where 联系人姓名=@客户名称
```

**注意事项：**
- 链式操作中，每个命令的输出格式都是管道格式（`rec123 字段=值`）
- `insert` 和 `update` 会自动检测是否有管道输出
- 如果命令后面没有管道，则不会输出记录（正常模式）
- 支持任意长度的链式操作

### 6. update 命令表名参数

`update` 命令支持在第一个参数位置指定表名，用于更新指定表而不是当前表。

**语法：**
```bash
t update [表名] 字段1=值1 字段2=值2 ...
t show | t update [表名] 字段1=值1 字段2=值2 ...
```

**示例：**
```bash
# 直接更新指定表
t update 订单表 状态=已完成 where 订单号=ORD001

# 管道更新指定表
t show | t update 订单表 状态=已完成
t show | t update 订单表 状态=@状态 where 订单号=@订单号
```

**注意事项：**
- 表名必须是第一个参数（在字段赋值和 where 关键字之前）
- 支持所有更新模式：直接更新、条件更新、管道更新、merge update
- 如果不指定表名，则更新当前表

## 复杂工作流示例

### 案例1：数据复制和转换
```bash
# 从订单表查询数据，插入到订单备份表
t use 订单表
t show 创建时间>2024-01-01 > /tmp/orders.txt
t use 订单备份表
cat /tmp/orders.txt | t insert 订单号=@订单号 客户名称=@客户名称 金额=@金额

# 或者直接管道操作
t use 订单表
t show 创建时间>2024-01-01 | t use 订单备份表
t show 创建时间>2024-01-01 | t insert 订单号=@订单号 客户名称=@客户名称 金额=@金额
```

### 案例2：批量状态更新
```bash
# 查询待处理订单，批量更新状态
t show 状态=待处理 | t update 状态=处理中

# 根据订单号更新订单状态（merge update）
t show 状态=待处理 | t update 状态=已完成 where 订单号=@订单号

# 只处理前100个
t show 状态=待处理 | head -100 | t update 状态=处理中
```

### 案例3：数据同步
```bash
# 从源表同步数据到目标表
t use 源表
t show | t update 目标表 状态=@状态 where 订单号=@订单号

# 跨表数据复制
t use 订单表
t show limit=10 | t insert 订单号=@订单号 客户名称=@客户名称 状态=新订单
```

### 案例4：数据清洗
```bash
# 批量修改状态
t show 状态=待审核 | t update 状态=审核中

# 按时间分批处理
t show 创建时间>2024-01-01 | head -50 | t update 标记=新客户

# 使用字段映射更新
t show | t update 新状态=@状态 新备注=@备注
```

### 案例5：关联查询
```bash
# 从订单表查询订单，然后查询对应的客户信息
t show 订单表 limit=10 | t show 客户表 where 联系人姓名=@客户名称

# 链式关联查询：订单 -> 客户 -> 限制输出
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称 | head -5

# 多条件关联查询
t show 订单表 | t show 客户表 where 联系人姓名=@客户名称 联系电话=@联系电话
```

### 案例6：链式管道操作
```bash
# 数据复制和转换流程
t show 订单表 limit=10 | t insert 订单备份表 订单号=@订单号 客户名称=@客户名称 | t update 订单备份表 状态=已备份

# 完整的数据处理流程：查询 -> 插入 -> 更新 -> 关联查询
t show 订单表 | t insert 订单备份表 订单号=@订单号 | t update 订单备份表 状态=已完成 | t show 客户表 where 联系人姓名=@客户名称

# 跨表数据同步流程
t show 源表 | t insert 目标表 字段1=@字段1 字段2=@字段2 | t update 目标表 状态=已同步
```

### 案例7：统计分析
```bash
# 统计各类客户数量
t show | grep "客户类型=企业" | wc -l
t show | grep "客户类型=个人" | wc -l

# 查看数据分布
t show | grep -o "信用等级=[^ ]*" | sort | uniq -c
```

## 工作原理

### 流式处理机制

1. **流式查询**：`show` 命令在管道模式下，查询一页 → 输出一页 → 下一页，内存占用恒定
2. **流式更新**：`update` 命令接收一条 → 处理一条 → 下一条，支持大规模数据集
3. **分批处理**：更新操作每10条一批，避免API限制和超时
4. **自动检测**：自动识别是否在管道模式中，无需额外参数

### Merge Update 处理流程

对于 `t show | t update col1=@col1 where col2=@col2`：

```
管道记录1: rec001 订单号=ORD001 状态=待处理
  → where条件：订单号=@订单号 → 从记录1获取：订单号=ORD001
  → 查询目标表：找到 订单号=ORD001 的记录
  → 更新字段：状态=@状态 → 从记录1获取：状态=待处理
  → 更新匹配记录：状态=待处理

管道记录2: rec002 订单号=ORD002 状态=已完成
  → where条件：订单号=@订单号 → 从记录2获取：订单号=ORD002
  → 查询目标表：找到 订单号=ORD002 的记录
  → 更新字段：状态=@状态 → 从记录2获取：状态=已完成
  → 更新匹配记录：状态=已完成

... 依此类推
```

**关键点：**
- 每条管道记录独立处理
- where 条件和 update 字段的值都从当前管道记录中获取
- 如果 where 条件匹配多条记录，都用管道记录的值更新
- 流式处理，逐条处理，不需要等待所有数据

## 性能特点

- **内存友好**：无论数据多大，内存占用都很小（恒定内存）
- **速度快**：边查询边处理，不用等全部数据加载
- **可扩展**：支持任意大小的数据集处理（万级记录）
- **稳定**：有错误处理，单个失败不影响整体
- **可中断**：随时可以 Ctrl+C 停止
- **进度显示**：大量数据（每50条）会显示处理进度

## 注意事项

1. **管道模式自动检测**：管道命令会自动进入流式模式，无需额外参数
2. **字段映射必须明确**：`insert` 命令在管道模式下必须指定字段映射或常量值
3. **批次大小**：更新操作每10条一批，避免API限制
4. **进度显示**：大量数据（>50条）会显示处理进度
5. **控制数量**：可以用 `head`/`tail` 控制处理数量
6. **表名参数**：`update` 命令的表名必须是第一个参数

## 故障排除

**问题：更新很慢**
- 正常，因为要走API，每10条一批
- 大量数据时会显示进度

**问题：管道断了**
- 检查是不是用了不兼容的命令
- 确保命令格式正确
- 检查网络连接

**问题：数据没变化**
- 确认查询条件是否正确
- 检查是否有权限更新这些记录
- merge update 模式下，确认 where 条件能匹配到记录

**问题：insert 命令报错"必须指定字段映射"**
- 管道模式下必须提供字段映射参数
- 使用 `@字段名` 或常量值语法

**问题：merge update 更新了0条记录**
- 检查 where 条件是否正确
- 确认目标表中存在匹配的记录
- 检查字段名是否匹配

**问题：关联查询没有找到记录**
- 检查 where 条件是否正确
- 确认管道记录中包含 where 条件中使用的字段
- 检查字段名是否匹配（管道记录中的字段名必须与 @字段名 一致）
- 确认目标表中存在匹配的记录

## 最佳实践

1. **使用字段映射**：尽量使用 `@字段名` 从管道记录中获取值，避免硬编码
2. **批量处理**：使用 `head` 限制数量进行测试，确认无误后再处理全部数据
3. **表名参数**：跨表操作时使用表名参数，避免频繁切换表格
4. **错误处理**：大量数据操作时注意观察错误信息，及时处理
5. **流式处理**：充分利用流式处理特性，处理大规模数据集
6. **关联查询**：使用 `show | show` 实现表之间的关联查询，类似 SQL JOIN
7. **字段名匹配**：确保管道记录中的字段名与 where 条件中使用的 `@字段名` 一致
8. **链式操作**：充分利用链式管道操作，实现复杂的数据处理流程

记住：管道操作就是先把数据查出来，然后一条一条传给后面的命令处理！
